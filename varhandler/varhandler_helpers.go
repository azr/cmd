// Code copyied from github.com/azr/generators/varhandler/varhandler_helpers.go; DO NOT EDIT
package main

import "net/http"

//HandleHTTPErrorWithDefaultStatus handles err if it can or just writes the header with default status
//
// if the err matches is any of : 
//  http.Handler
// 	type HTTPError interface {
// 	    HTTPError() (error string, code int)
//  }
//  type SelfHTTPError interface {
//  	HTTPError(w http.ResponseWriter)
//  }
//
// according funcs will be called.
// This code is generated by varhandler and this func will be called when your wrapped func returns
// an error with default status 
func HandleHTTPErrorWithDefaultStatus(w http.ResponseWriter, r *http.Request, status int, err error) {
	type HTTPError interface {
		HTTPError() (error string, code int)
	}
	type SelfHTTPError interface {
		HTTPError(w http.ResponseWriter)
	}
	switch t := err.(type) {
	default:
		w.WriteHeader(status)
	case HTTPError:
		err, code := t.HTTPError()
		http.Error(w, err, code)
	case http.Handler:
		t.ServeHTTP(w, r)
	case SelfHTTPError:
		t.HTTPError(w)
	}
}

//HandleHTTPResponse will check if resp is any of :
// http.Handler
// []byte
// type Byter interface {
// 	Bytes() []byte
// }
// type Stringer interface {
// 	String() string
// }
// and just output the bytes in case of []byte,Byter,Stringer or 
// call ServeHTTP if it's an http.Handler
func HandleHTTPResponse(w http.ResponseWriter, r *http.Request, resp interface{}) {
	type Byter interface {
		Bytes() []byte
	}
	type Stringer interface {
		String() string
	}
	switch t := resp.(type) {
	default:
		// I don't know that type !
	case http.Handler:
		t.ServeHTTP(w, r) // resp knows how to handle itself
	case Byter:
		w.Write(t.Bytes())
	case Stringer:
		w.Write([]byte(t.String()))
	case []byte:
		w.Write(t)
	}
}
